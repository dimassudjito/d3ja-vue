{"remainingRequest":"/home/dimas/Dev/d3ja-vue/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/dimas/Dev/d3ja-vue/src/lib-components/TreeOfLife.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/dimas/Dev/d3ja-vue/src/lib-components/TreeOfLife.vue","mtime":1623728970638},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwoKZnVuY3Rpb24gbGlua1N0ZXAoc3RhcnRBbmdsZSwgc3RhcnRSYWRpdXMsIGVuZEFuZ2xlLCBlbmRSYWRpdXMpIHsKICBjb25zdCBjMCA9IE1hdGguY29zKChzdGFydEFuZ2xlID0gKChzdGFydEFuZ2xlIC0gOTApIC8gMTgwKSAqIE1hdGguUEkpKQogIGNvbnN0IHMwID0gTWF0aC5zaW4oc3RhcnRBbmdsZSkKICBjb25zdCBjMSA9IE1hdGguY29zKChlbmRBbmdsZSA9ICgoZW5kQW5nbGUgLSA5MCkgLyAxODApICogTWF0aC5QSSkpCiAgY29uc3QgczEgPSBNYXRoLnNpbihlbmRBbmdsZSkKICByZXR1cm4gKAogICAgJ00nICsKICAgIHN0YXJ0UmFkaXVzICogYzAgKwogICAgJywnICsKICAgIHN0YXJ0UmFkaXVzICogczAgKwogICAgKGVuZEFuZ2xlID09PSBzdGFydEFuZ2xlCiAgICAgID8gJycKICAgICAgOiAnQScgKwogICAgICAgIHN0YXJ0UmFkaXVzICsKICAgICAgICAnLCcgKwogICAgICAgIHN0YXJ0UmFkaXVzICsKICAgICAgICAnIDAgMCAnICsKICAgICAgICAoZW5kQW5nbGUgPiBzdGFydEFuZ2xlID8gMSA6IDApICsKICAgICAgICAnICcgKwogICAgICAgIHN0YXJ0UmFkaXVzICogYzEgKwogICAgICAgICcsJyArCiAgICAgICAgc3RhcnRSYWRpdXMgKiBzMSkgKwogICAgJ0wnICsKICAgIGVuZFJhZGl1cyAqIGMxICsKICAgICcsJyArCiAgICBlbmRSYWRpdXMgKiBzMQogICkKfQoKZnVuY3Rpb24gbGlua0NvbnN0YW50KGQpIHsKICByZXR1cm4gbGlua1N0ZXAoZC5zb3VyY2UueCwgZC5zb3VyY2UueSwgZC50YXJnZXQueCwgZC50YXJnZXQueSkKfQoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdUcmVlT2ZMaWZlJywKICBwcm9wczogewogICAgdHJlZTogU3RyaW5nCiAgfSwKICBtb3VudGVkKCkgewogICAgdGhpcy5nZXRDaGFydCgpCiAgfSwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgd2lkdGg6IDkwMAogICAgfQogIH0sCiAgbWV0aG9kczogewogICAgcGFyc2VOZXdpY2soYSkgewogICAgICBmb3IgKAogICAgICAgIHZhciBlID0gW10sIHIgPSB7fSwgcyA9IGEuc3BsaXQoL1xzKig7fFwofFwpfCx8OilccyovKSwgdCA9IDA7CiAgICAgICAgdCA8IHMubGVuZ3RoOwogICAgICAgIHQrKwogICAgICApIHsKICAgICAgICB2YXIgbiA9IHNbdF0KICAgICAgICBzd2l0Y2ggKG4pIHsKICAgICAgICAgIGNhc2UgJygnOgogICAgICAgICAgICB2YXIgYyA9IHt9CiAgICAgICAgICAgIDsoci5icmFuY2hzZXQgPSBbY10pLCBlLnB1c2gociksIChyID0gYykKICAgICAgICAgICAgYnJlYWsKICAgICAgICAgIGNhc2UgJywnOgogICAgICAgICAgICB2YXIgYyA9IHt9CiAgICAgICAgICAgIGVbZS5sZW5ndGggLSAxXS5icmFuY2hzZXQucHVzaChjKSwgKHIgPSBjKQogICAgICAgICAgICBicmVhawogICAgICAgICAgY2FzZSAnKSc6CiAgICAgICAgICAgIHIgPSBlLnBvcCgpCiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICBjYXNlICc6JzoKICAgICAgICAgICAgYnJlYWsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHZhciBoID0gc1t0IC0gMV0KICAgICAgICAgICAgJyknID09IGggfHwgJygnID09IGggfHwgJywnID09IGgKICAgICAgICAgICAgICA/IChyLm5hbWUgPSBuKQogICAgICAgICAgICAgIDogJzonID09IGggJiYgKHIubGVuZ3RoID0gcGFyc2VGbG9hdChuKSkKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHIKICAgIH0sCiAgICBnZXRDaGFydCgpIHsKICAgICAgbGV0IGRhdGEgPSB0aGlzLnBhcnNlTmV3aWNrKHRoaXMudHJlZSkKICAgICAgbGV0IG91dGVyUmFkaXVzID0gdGhpcy53aWR0aCAvIDIKICAgICAgbGV0IGlubmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAxNzAKCiAgICAgIGxldCBsZWdlbmQgPSAoc3ZnKSA9PiB7CiAgICAgICAgY29uc3QgZyA9IHN2ZwogICAgICAgICAgLnNlbGVjdEFsbCgnZycpCiAgICAgICAgICAuZGF0YShjb2xvci5kb21haW4oKSkKICAgICAgICAgIC5qb2luKCdnJykKICAgICAgICAgIC5hdHRyKAogICAgICAgICAgICAndHJhbnNmb3JtJywKICAgICAgICAgICAgKGQsIGkpID0+IGB0cmFuc2xhdGUoJHstb3V0ZXJSYWRpdXN9LCR7LW91dGVyUmFkaXVzICsgaSAqIDIwfSlgCiAgICAgICAgICApCgogICAgICAgIGcuYXBwZW5kKCdyZWN0JykKICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE4KQogICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE4KQogICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcikKCiAgICAgICAgZy5hcHBlbmQoJ3RleHQnKQogICAgICAgICAgLmF0dHIoJ3gnLCAyNCkKICAgICAgICAgIC5hdHRyKCd5JywgOSkKICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKQogICAgICAgICAgLnRleHQoKGQpID0+IGQpCiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGxpbmtWYXJpYWJsZShkKSB7CiAgICAgICAgcmV0dXJuIGxpbmtTdGVwKAogICAgICAgICAgZC5zb3VyY2UueCwKICAgICAgICAgIGQuc291cmNlLnJhZGl1cywKICAgICAgICAgIGQudGFyZ2V0LngsCiAgICAgICAgICBkLnRhcmdldC5yYWRpdXMKICAgICAgICApCiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGxpbmtFeHRlbnNpb25Db25zdGFudChkKSB7CiAgICAgICAgcmV0dXJuIGxpbmtTdGVwKGQudGFyZ2V0LngsIGQudGFyZ2V0LnksIGQudGFyZ2V0LngsIGlubmVyUmFkaXVzKQogICAgICB9CgogICAgICBmdW5jdGlvbiBsaW5rRXh0ZW5zaW9uVmFyaWFibGUoZCkgewogICAgICAgIHJldHVybiBsaW5rU3RlcChkLnRhcmdldC54LCBkLnRhcmdldC5yYWRpdXMsIGQudGFyZ2V0LngsIGlubmVyUmFkaXVzKQogICAgICB9CgogICAgICAvLyBTZXQgdGhlIGNvbG9yIG9mIGVhY2ggbm9kZSBieSByZWN1cnNpdmVseSBpbmhlcml0aW5nLgogICAgICBmdW5jdGlvbiBzZXRDb2xvcihkKSB7CiAgICAgICAgdmFyIG5hbWUgPSBkLmRhdGEubmFtZQogICAgICAgIGQuY29sb3IgPQogICAgICAgICAgY29sb3IuZG9tYWluKCkuaW5kZXhPZihuYW1lKSA+PSAwCiAgICAgICAgICAgID8gY29sb3IobmFtZSkKICAgICAgICAgICAgOiBkLnBhcmVudAogICAgICAgICAgICA/IGQucGFyZW50LmNvbG9yCiAgICAgICAgICAgIDogbnVsbAogICAgICAgIGlmIChkLmNoaWxkcmVuKSBkLmNoaWxkcmVuLmZvckVhY2goc2V0Q29sb3IpCiAgICAgIH0KCiAgICAgIC8vIFNldCB0aGUgcmFkaXVzIG9mIGVhY2ggbm9kZSBieSByZWN1cnNpdmVseSBzdW1taW5nIGFuZCBzY2FsaW5nIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByb290LgogICAgICBmdW5jdGlvbiBzZXRSYWRpdXMoZCwgeTAsIGspIHsKICAgICAgICBkLnJhZGl1cyA9ICh5MCArPSBkLmRhdGEubGVuZ3RoKSAqIGsKICAgICAgICBpZiAoZC5jaGlsZHJlbikgZC5jaGlsZHJlbi5mb3JFYWNoKChkKSA9PiBzZXRSYWRpdXMoZCwgeTAsIGspKQogICAgICB9CgogICAgICAvLyBDb21wdXRlIHRoZSBtYXhpbXVtIGN1bXVsYXRpdmUgbGVuZ3RoIG9mIGFueSBub2RlIGluIHRoZSB0cmVlLgogICAgICBmdW5jdGlvbiBtYXhMZW5ndGgoZCkgewogICAgICAgIHJldHVybiBkLmRhdGEubGVuZ3RoICsgKGQuY2hpbGRyZW4gPyBkMy5tYXgoZC5jaGlsZHJlbiwgbWF4TGVuZ3RoKSA6IDApCiAgICAgIH0KCiAgICAgIGxldCBjb2xvciA9IGQzCiAgICAgICAgLnNjYWxlT3JkaW5hbCgpCiAgICAgICAgLmRvbWFpbihbJ0JhY3RlcmlhJywgJ0V1a2FyeW90YScsICdBcmNoYWVhJ10pCiAgICAgICAgLnJhbmdlKGQzLnNjaGVtZUNhdGVnb3J5MTApCgogICAgICBsZXQgY2x1c3RlciA9IGQzCiAgICAgICAgLmNsdXN0ZXIoKQogICAgICAgIC5zaXplKFszNjAsIGlubmVyUmFkaXVzXSkKICAgICAgICAuc2VwYXJhdGlvbigoYSwgYikgPT4gMSkKICAgICAgY29uc3Qgcm9vdCA9IGQzCiAgICAgICAgLmhpZXJhcmNoeShkYXRhLCAoZCkgPT4gZC5icmFuY2hzZXQpCiAgICAgICAgLnN1bSgoZCkgPT4gKGQuYnJhbmNoc2V0ID8gMCA6IDEpKQogICAgICAgIC5zb3J0KAogICAgICAgICAgKGEsIGIpID0+CiAgICAgICAgICAgIGEudmFsdWUgLSBiLnZhbHVlIHx8IGQzLmFzY2VuZGluZyhhLmRhdGEubGVuZ3RoLCBiLmRhdGEubGVuZ3RoKQogICAgICAgICkKCiAgICAgIGNsdXN0ZXIocm9vdCkKICAgICAgc2V0UmFkaXVzKHJvb3QsIChyb290LmRhdGEubGVuZ3RoID0gMCksIGlubmVyUmFkaXVzIC8gbWF4TGVuZ3RoKHJvb3QpKQogICAgICBzZXRDb2xvcihyb290KQoKICAgICAgY29uc3Qgc3ZnID0gZDMKICAgICAgICAuc2VsZWN0KCcuY29udGFpbmVyJykKICAgICAgICAuYXBwZW5kKCdzdmcnKQogICAgICAgIC5hdHRyKCd2aWV3Qm94JywgWy1vdXRlclJhZGl1cywgLW91dGVyUmFkaXVzLCB0aGlzLndpZHRoLCB0aGlzLndpZHRoXSkKICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnc2Fucy1zZXJpZicpCiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIDEwKQoKICAgICAgc3ZnLmFwcGVuZCgnZycpLmNhbGwobGVnZW5kKQoKICAgICAgc3ZnLmFwcGVuZCgnc3R5bGUnKS50ZXh0KGAKCi5saW5rLS1hY3RpdmUgewogIHN0cm9rZTogIzAwMCAhaW1wb3J0YW50OwogIHN0cm9rZS13aWR0aDogMS41cHg7Cn0KCi5saW5rLWV4dGVuc2lvbi0tYWN0aXZlIHsKICBzdHJva2Utb3BhY2l0eTogLjY7Cn0KCi5sYWJlbC0tYWN0aXZlIHsKICBmb250LXdlaWdodDogYm9sZDsKfQoKYCkKCiAgICAgIGNvbnN0IGxpbmtFeHRlbnNpb24gPSBzdmcKICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAuYXR0cignZmlsbCcsICdub25lJykKICAgICAgICAuYXR0cignc3Ryb2tlJywgJyMwMDAnKQogICAgICAgIC5hdHRyKCdzdHJva2Utb3BhY2l0eScsIDAuMjUpCiAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpCiAgICAgICAgLmRhdGEocm9vdC5saW5rcygpLmZpbHRlcigoZCkgPT4gIWQudGFyZ2V0LmNoaWxkcmVuKSkKICAgICAgICAuam9pbigncGF0aCcpCiAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkgewogICAgICAgICAgZC50YXJnZXQubGlua0V4dGVuc2lvbk5vZGUgPSB0aGlzCiAgICAgICAgfSkKICAgICAgICAuYXR0cignZCcsIGxpbmtFeHRlbnNpb25Db25zdGFudCkKCiAgICAgIGNvbnN0IGxpbmsgPSBzdmcKICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAuYXR0cignZmlsbCcsICdub25lJykKICAgICAgICAuYXR0cignc3Ryb2tlJywgJyMwMDAnKQogICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKQogICAgICAgIC5kYXRhKHJvb3QubGlua3MoKSkKICAgICAgICAuam9pbigncGF0aCcpCiAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkgewogICAgICAgICAgZC50YXJnZXQubGlua05vZGUgPSB0aGlzCiAgICAgICAgfSkKICAgICAgICAuYXR0cignZCcsIGxpbmtDb25zdGFudCkKICAgICAgICAuYXR0cignc3Ryb2tlJywgKGQpID0+IGQudGFyZ2V0LmNvbG9yKQoKICAgICAgc3ZnCiAgICAgICAgLmFwcGVuZCgnZycpCiAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpCiAgICAgICAgLmRhdGEocm9vdC5sZWF2ZXMoKSkKICAgICAgICAuam9pbigndGV4dCcpCiAgICAgICAgLmF0dHIoJ2R5JywgJy4zMWVtJykKICAgICAgICAuYXR0cigKICAgICAgICAgICd0cmFuc2Zvcm0nLAogICAgICAgICAgKGQpID0+CiAgICAgICAgICAgIGByb3RhdGUoJHtkLnggLSA5MH0pIHRyYW5zbGF0ZSgke2lubmVyUmFkaXVzICsgNH0sMCkkewogICAgICAgICAgICAgIGQueCA8IDE4MCA/ICcnIDogJyByb3RhdGUoMTgwKScKICAgICAgICAgICAgfWAKICAgICAgICApCiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgKGQpID0+IChkLnggPCAxODAgPyAnc3RhcnQnIDogJ2VuZCcpKQogICAgICAgIC50ZXh0KChkKSA9PiBkLmRhdGEubmFtZS5yZXBsYWNlKC9fL2csICcgJykpCiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBtb3VzZW92ZXJlZCh0cnVlKSkKICAgICAgICAub24oJ21vdXNlb3V0JywgbW91c2VvdmVyZWQoZmFsc2UpKQoKICAgICAgZnVuY3Rpb24gdXBkYXRlKGNoZWNrZWQpIHsKICAgICAgICBjb25zdCB0ID0gZDMudHJhbnNpdGlvbigpLmR1cmF0aW9uKDc1MCkKICAgICAgICBsaW5rRXh0ZW5zaW9uCiAgICAgICAgICAudHJhbnNpdGlvbih0KQogICAgICAgICAgLmF0dHIoJ2QnLCBjaGVja2VkID8gbGlua0V4dGVuc2lvblZhcmlhYmxlIDogbGlua0V4dGVuc2lvbkNvbnN0YW50KQogICAgICAgIGxpbmsudHJhbnNpdGlvbih0KS5hdHRyKCdkJywgY2hlY2tlZCA/IGxpbmtWYXJpYWJsZSA6IGxpbmtDb25zdGFudCkKICAgICAgfQoKICAgICAgZnVuY3Rpb24gbW91c2VvdmVyZWQoYWN0aXZlKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50LCBkKSB7CiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnbGFiZWwtLWFjdGl2ZScsIGFjdGl2ZSkKICAgICAgICAgIGQzLnNlbGVjdChkLmxpbmtFeHRlbnNpb25Ob2RlKQogICAgICAgICAgICAuY2xhc3NlZCgnbGluay1leHRlbnNpb24tLWFjdGl2ZScsIGFjdGl2ZSkKICAgICAgICAgICAgLnJhaXNlKCkKICAgICAgICAgIGRvCiAgICAgICAgICAgIGQzLnNlbGVjdChkLmxpbmtOb2RlKQogICAgICAgICAgICAgIC5jbGFzc2VkKCdsaW5rLS1hY3RpdmUnLCBhY3RpdmUpCiAgICAgICAgICAgICAgLnJhaXNlKCkKICAgICAgICAgIHdoaWxlICgoZCA9IGQucGFyZW50KSkKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN2Zy5ub2RlKCksIHsgdXBkYXRlIH0pCiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["TreeOfLife.vue"],"names":[],"mappings":";;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"TreeOfLife.vue","sourceRoot":"src/lib-components","sourcesContent":["<template>\n  <div class=\"container\"></div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n\nfunction linkStep(startAngle, startRadius, endAngle, endRadius) {\n  const c0 = Math.cos((startAngle = ((startAngle - 90) / 180) * Math.PI))\n  const s0 = Math.sin(startAngle)\n  const c1 = Math.cos((endAngle = ((endAngle - 90) / 180) * Math.PI))\n  const s1 = Math.sin(endAngle)\n  return (\n    'M' +\n    startRadius * c0 +\n    ',' +\n    startRadius * s0 +\n    (endAngle === startAngle\n      ? ''\n      : 'A' +\n        startRadius +\n        ',' +\n        startRadius +\n        ' 0 0 ' +\n        (endAngle > startAngle ? 1 : 0) +\n        ' ' +\n        startRadius * c1 +\n        ',' +\n        startRadius * s1) +\n    'L' +\n    endRadius * c1 +\n    ',' +\n    endRadius * s1\n  )\n}\n\nfunction linkConstant(d) {\n  return linkStep(d.source.x, d.source.y, d.target.x, d.target.y)\n}\n\nexport default {\n  name: 'TreeOfLife',\n  props: {\n    tree: String\n  },\n  mounted() {\n    this.getChart()\n  },\n  data() {\n    return {\n      width: 900\n    }\n  },\n  methods: {\n    parseNewick(a) {\n      for (\n        var e = [], r = {}, s = a.split(/\\s*(;|\\(|\\)|,|:)\\s*/), t = 0;\n        t < s.length;\n        t++\n      ) {\n        var n = s[t]\n        switch (n) {\n          case '(':\n            var c = {}\n            ;(r.branchset = [c]), e.push(r), (r = c)\n            break\n          case ',':\n            var c = {}\n            e[e.length - 1].branchset.push(c), (r = c)\n            break\n          case ')':\n            r = e.pop()\n            break\n          case ':':\n            break\n          default:\n            var h = s[t - 1]\n            ')' == h || '(' == h || ',' == h\n              ? (r.name = n)\n              : ':' == h && (r.length = parseFloat(n))\n        }\n      }\n      return r\n    },\n    getChart() {\n      let data = this.parseNewick(this.tree)\n      let outerRadius = this.width / 2\n      let innerRadius = outerRadius - 170\n\n      let legend = (svg) => {\n        const g = svg\n          .selectAll('g')\n          .data(color.domain())\n          .join('g')\n          .attr(\n            'transform',\n            (d, i) => `translate(${-outerRadius},${-outerRadius + i * 20})`\n          )\n\n        g.append('rect')\n          .attr('width', 18)\n          .attr('height', 18)\n          .attr('fill', color)\n\n        g.append('text')\n          .attr('x', 24)\n          .attr('y', 9)\n          .attr('dy', '0.35em')\n          .text((d) => d)\n      }\n\n      function linkVariable(d) {\n        return linkStep(\n          d.source.x,\n          d.source.radius,\n          d.target.x,\n          d.target.radius\n        )\n      }\n\n      function linkExtensionConstant(d) {\n        return linkStep(d.target.x, d.target.y, d.target.x, innerRadius)\n      }\n\n      function linkExtensionVariable(d) {\n        return linkStep(d.target.x, d.target.radius, d.target.x, innerRadius)\n      }\n\n      // Set the color of each node by recursively inheriting.\n      function setColor(d) {\n        var name = d.data.name\n        d.color =\n          color.domain().indexOf(name) >= 0\n            ? color(name)\n            : d.parent\n            ? d.parent.color\n            : null\n        if (d.children) d.children.forEach(setColor)\n      }\n\n      // Set the radius of each node by recursively summing and scaling the distance from the root.\n      function setRadius(d, y0, k) {\n        d.radius = (y0 += d.data.length) * k\n        if (d.children) d.children.forEach((d) => setRadius(d, y0, k))\n      }\n\n      // Compute the maximum cumulative length of any node in the tree.\n      function maxLength(d) {\n        return d.data.length + (d.children ? d3.max(d.children, maxLength) : 0)\n      }\n\n      let color = d3\n        .scaleOrdinal()\n        .domain(['Bacteria', 'Eukaryota', 'Archaea'])\n        .range(d3.schemeCategory10)\n\n      let cluster = d3\n        .cluster()\n        .size([360, innerRadius])\n        .separation((a, b) => 1)\n      const root = d3\n        .hierarchy(data, (d) => d.branchset)\n        .sum((d) => (d.branchset ? 0 : 1))\n        .sort(\n          (a, b) =>\n            a.value - b.value || d3.ascending(a.data.length, b.data.length)\n        )\n\n      cluster(root)\n      setRadius(root, (root.data.length = 0), innerRadius / maxLength(root))\n      setColor(root)\n\n      const svg = d3\n        .select('.container')\n        .append('svg')\n        .attr('viewBox', [-outerRadius, -outerRadius, this.width, this.width])\n        .attr('font-family', 'sans-serif')\n        .attr('font-size', 10)\n\n      svg.append('g').call(legend)\n\n      svg.append('style').text(`\n\n.link--active {\n  stroke: #000 !important;\n  stroke-width: 1.5px;\n}\n\n.link-extension--active {\n  stroke-opacity: .6;\n}\n\n.label--active {\n  font-weight: bold;\n}\n\n`)\n\n      const linkExtension = svg\n        .append('g')\n        .attr('fill', 'none')\n        .attr('stroke', '#000')\n        .attr('stroke-opacity', 0.25)\n        .selectAll('path')\n        .data(root.links().filter((d) => !d.target.children))\n        .join('path')\n        .each(function(d) {\n          d.target.linkExtensionNode = this\n        })\n        .attr('d', linkExtensionConstant)\n\n      const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .attr('stroke', '#000')\n        .selectAll('path')\n        .data(root.links())\n        .join('path')\n        .each(function(d) {\n          d.target.linkNode = this\n        })\n        .attr('d', linkConstant)\n        .attr('stroke', (d) => d.target.color)\n\n      svg\n        .append('g')\n        .selectAll('text')\n        .data(root.leaves())\n        .join('text')\n        .attr('dy', '.31em')\n        .attr(\n          'transform',\n          (d) =>\n            `rotate(${d.x - 90}) translate(${innerRadius + 4},0)${\n              d.x < 180 ? '' : ' rotate(180)'\n            }`\n        )\n        .attr('text-anchor', (d) => (d.x < 180 ? 'start' : 'end'))\n        .text((d) => d.data.name.replace(/_/g, ' '))\n        .on('mouseover', mouseovered(true))\n        .on('mouseout', mouseovered(false))\n\n      function update(checked) {\n        const t = d3.transition().duration(750)\n        linkExtension\n          .transition(t)\n          .attr('d', checked ? linkExtensionVariable : linkExtensionConstant)\n        link.transition(t).attr('d', checked ? linkVariable : linkConstant)\n      }\n\n      function mouseovered(active) {\n        return function(event, d) {\n          d3.select(this).classed('label--active', active)\n          d3.select(d.linkExtensionNode)\n            .classed('link-extension--active', active)\n            .raise()\n          do\n            d3.select(d.linkNode)\n              .classed('link--active', active)\n              .raise()\n          while ((d = d.parent))\n        }\n      }\n\n      return Object.assign(svg.node(), { update })\n    }\n  }\n}\n</script>\n\n<style></style>\n"]}]}
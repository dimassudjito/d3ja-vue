{"remainingRequest":"/home/dimas/Dev/d3ja-vue/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/dimas/Dev/d3ja-vue/src/lib-components/TreeOfLife.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/dimas/Dev/d3ja-vue/src/lib-components/TreeOfLife.vue","mtime":1623723658850},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/dimas/Dev/d3ja-vue/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJwoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdUcmVlT2ZMaWZlJywKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgbGlmZToKICAgICAgICAnKEJvdmluZTowLjY5Mzk1LChHaWJib246MC4zNjA3OSwoT3Jhbmc6MC4zMzYzNiwoR29yaWxsYTowLjE3MTQ3LChDaGltcDowLjE5MjY4LCBIdW1hbjowLjExOTI3KTowLjA4Mzg2KTowLjA2MTI0KTowLjE1MDU3KTowLjU0OTM5LE1vdXNlOjEuMjE0NjApOjAuMTA7JwogICAgfQogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuZ2V0Q2hhcnQoKQogIH0sCiAgbWV0aG9kczogewogICAgZ2V0Q2hhcnQoKSB7CiAgICAgIGZ1bmN0aW9uIHBhcnNlTmV3aWNrKGEpIHsKICAgICAgICBmb3IgKAogICAgICAgICAgdmFyIGUgPSBbXSwgciA9IHt9LCBzID0gYS5zcGxpdCgvXHMqKDt8XCh8XCl8LHw6KVxzKi8pLCB0ID0gMDsKICAgICAgICAgIHQgPCBzLmxlbmd0aDsKICAgICAgICAgIHQrKwogICAgICAgICkgewogICAgICAgICAgdmFyIG4gPSBzW3RdCiAgICAgICAgICBzd2l0Y2ggKG4pIHsKICAgICAgICAgICAgY2FzZSAnKCc6CiAgICAgICAgICAgICAgdmFyIGMgPSB7fQogICAgICAgICAgICAgIDsoci5icmFuY2hzZXQgPSBbY10pLCBlLnB1c2gociksIChyID0gYykKICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBjYXNlICcsJzoKICAgICAgICAgICAgICB2YXIgYyA9IHt9CiAgICAgICAgICAgICAgZVtlLmxlbmd0aCAtIDFdLmJyYW5jaHNldC5wdXNoKGMpLCAociA9IGMpCiAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgY2FzZSAnKSc6CiAgICAgICAgICAgICAgciA9IGUucG9wKCkKICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBjYXNlICc6JzoKICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgIHZhciBoID0gc1t0IC0gMV0KICAgICAgICAgICAgICAnKScgPT0gaCB8fCAnKCcgPT0gaCB8fCAnLCcgPT0gaAogICAgICAgICAgICAgICAgPyAoci5uYW1lID0gbikKICAgICAgICAgICAgICAgIDogJzonID09IGggJiYgKHIubGVuZ3RoID0gcGFyc2VGbG9hdChuKSkKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIHIKICAgICAgfQoKICAgICAgbGV0IGRhdGEgPSBwYXJzZU5ld2ljayh0aGlzLmxpZmUpCiAgICAgIGxldCB3aWR0aCA9IDkwMAogICAgICBsZXQgb3V0ZXJSYWRpdXMgPSB3aWR0aCAvIDIKICAgICAgbGV0IGlubmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAxNzAKCiAgICAgIGxldCBsZWdlbmQgPSAoc3ZnKSA9PiB7CiAgICAgICAgY29uc3QgZyA9IHN2ZwogICAgICAgICAgLnNlbGVjdEFsbCgnZycpCiAgICAgICAgICAuZGF0YShjb2xvci5kb21haW4oKSkKICAgICAgICAgIC5qb2luKCdnJykKICAgICAgICAgIC5hdHRyKAogICAgICAgICAgICAndHJhbnNmb3JtJywKICAgICAgICAgICAgKGQsIGkpID0+IGB0cmFuc2xhdGUoJHstb3V0ZXJSYWRpdXN9LCR7LW91dGVyUmFkaXVzICsgaSAqIDIwfSlgCiAgICAgICAgICApCgogICAgICAgIGcuYXBwZW5kKCdyZWN0JykKICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDE4KQogICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE4KQogICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjb2xvcikKCiAgICAgICAgZy5hcHBlbmQoJ3RleHQnKQogICAgICAgICAgLmF0dHIoJ3gnLCAyNCkKICAgICAgICAgIC5hdHRyKCd5JywgOSkKICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKQogICAgICAgICAgLnRleHQoKGQpID0+IGQpCiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGxpbmtTdGVwKHN0YXJ0QW5nbGUsIHN0YXJ0UmFkaXVzLCBlbmRBbmdsZSwgZW5kUmFkaXVzKSB7CiAgICAgICAgY29uc3QgYzAgPSBNYXRoLmNvcygoc3RhcnRBbmdsZSA9ICgoc3RhcnRBbmdsZSAtIDkwKSAvIDE4MCkgKiBNYXRoLlBJKSkKICAgICAgICBjb25zdCBzMCA9IE1hdGguc2luKHN0YXJ0QW5nbGUpCiAgICAgICAgY29uc3QgYzEgPSBNYXRoLmNvcygoZW5kQW5nbGUgPSAoKGVuZEFuZ2xlIC0gOTApIC8gMTgwKSAqIE1hdGguUEkpKQogICAgICAgIGNvbnN0IHMxID0gTWF0aC5zaW4oZW5kQW5nbGUpCiAgICAgICAgcmV0dXJuICgKICAgICAgICAgICdNJyArCiAgICAgICAgICBzdGFydFJhZGl1cyAqIGMwICsKICAgICAgICAgICcsJyArCiAgICAgICAgICBzdGFydFJhZGl1cyAqIHMwICsKICAgICAgICAgIChlbmRBbmdsZSA9PT0gc3RhcnRBbmdsZQogICAgICAgICAgICA/ICcnCiAgICAgICAgICAgIDogJ0EnICsKICAgICAgICAgICAgICBzdGFydFJhZGl1cyArCiAgICAgICAgICAgICAgJywnICsKICAgICAgICAgICAgICBzdGFydFJhZGl1cyArCiAgICAgICAgICAgICAgJyAwIDAgJyArCiAgICAgICAgICAgICAgKGVuZEFuZ2xlID4gc3RhcnRBbmdsZSA/IDEgOiAwKSArCiAgICAgICAgICAgICAgJyAnICsKICAgICAgICAgICAgICBzdGFydFJhZGl1cyAqIGMxICsKICAgICAgICAgICAgICAnLCcgKwogICAgICAgICAgICAgIHN0YXJ0UmFkaXVzICogczEpICsKICAgICAgICAgICdMJyArCiAgICAgICAgICBlbmRSYWRpdXMgKiBjMSArCiAgICAgICAgICAnLCcgKwogICAgICAgICAgZW5kUmFkaXVzICogczEKICAgICAgICApCiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGxpbmtFeHRlbnNpb25Db25zdGFudChkKSB7CiAgICAgICAgcmV0dXJuIGxpbmtTdGVwKGQudGFyZ2V0LngsIGQudGFyZ2V0LnksIGQudGFyZ2V0LngsIGlubmVyUmFkaXVzKQogICAgICB9CgogICAgICBmdW5jdGlvbiBsaW5rRXh0ZW5zaW9uVmFyaWFibGUoZCkgewogICAgICAgIHJldHVybiBsaW5rU3RlcChkLnRhcmdldC54LCBkLnRhcmdldC5yYWRpdXMsIGQudGFyZ2V0LngsIGlubmVyUmFkaXVzKQogICAgICB9CgogICAgICBmdW5jdGlvbiBsaW5rQ29uc3RhbnQoZCkgewogICAgICAgIHJldHVybiBsaW5rU3RlcChkLnNvdXJjZS54LCBkLnNvdXJjZS55LCBkLnRhcmdldC54LCBkLnRhcmdldC55KQogICAgICB9CgogICAgICBmdW5jdGlvbiBsaW5rVmFyaWFibGUoZCkgewogICAgICAgIHJldHVybiBsaW5rU3RlcCgKICAgICAgICAgIGQuc291cmNlLngsCiAgICAgICAgICBkLnNvdXJjZS5yYWRpdXMsCiAgICAgICAgICBkLnRhcmdldC54LAogICAgICAgICAgZC50YXJnZXQucmFkaXVzCiAgICAgICAgKQogICAgICB9CgogICAgICAvLyBTZXQgdGhlIGNvbG9yIG9mIGVhY2ggbm9kZSBieSByZWN1cnNpdmVseSBpbmhlcml0aW5nLgogICAgICBmdW5jdGlvbiBzZXRDb2xvcihkKSB7CiAgICAgICAgdmFyIG5hbWUgPSBkLmRhdGEubmFtZQogICAgICAgIGQuY29sb3IgPQogICAgICAgICAgY29sb3IuZG9tYWluKCkuaW5kZXhPZihuYW1lKSA+PSAwCiAgICAgICAgICAgID8gY29sb3IobmFtZSkKICAgICAgICAgICAgOiBkLnBhcmVudAogICAgICAgICAgICA/IGQucGFyZW50LmNvbG9yCiAgICAgICAgICAgIDogbnVsbAogICAgICAgIGlmIChkLmNoaWxkcmVuKSBkLmNoaWxkcmVuLmZvckVhY2goc2V0Q29sb3IpCiAgICAgIH0KCiAgICAgIC8vIFNldCB0aGUgcmFkaXVzIG9mIGVhY2ggbm9kZSBieSByZWN1cnNpdmVseSBzdW1taW5nIGFuZCBzY2FsaW5nIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByb290LgogICAgICBmdW5jdGlvbiBzZXRSYWRpdXMoZCwgeTAsIGspIHsKICAgICAgICBkLnJhZGl1cyA9ICh5MCArPSBkLmRhdGEubGVuZ3RoKSAqIGsKICAgICAgICBpZiAoZC5jaGlsZHJlbikgZC5jaGlsZHJlbi5mb3JFYWNoKChkKSA9PiBzZXRSYWRpdXMoZCwgeTAsIGspKQogICAgICB9CgogICAgICAvLyBDb21wdXRlIHRoZSBtYXhpbXVtIGN1bXVsYXRpdmUgbGVuZ3RoIG9mIGFueSBub2RlIGluIHRoZSB0cmVlLgogICAgICBmdW5jdGlvbiBtYXhMZW5ndGgoZCkgewogICAgICAgIHJldHVybiBkLmRhdGEubGVuZ3RoICsgKGQuY2hpbGRyZW4gPyBkMy5tYXgoZC5jaGlsZHJlbiwgbWF4TGVuZ3RoKSA6IDApCiAgICAgIH0KCiAgICAgIGxldCBjb2xvciA9IGQzCiAgICAgICAgLnNjYWxlT3JkaW5hbCgpCiAgICAgICAgLmRvbWFpbihbJ0JhY3RlcmlhJywgJ0V1a2FyeW90YScsICdBcmNoYWVhJ10pCiAgICAgICAgLnJhbmdlKGQzLnNjaGVtZUNhdGVnb3J5MTApCgogICAgICBsZXQgY2x1c3RlciA9IGQzCiAgICAgICAgLmNsdXN0ZXIoKQogICAgICAgIC5zaXplKFszNjAsIGlubmVyUmFkaXVzXSkKICAgICAgICAuc2VwYXJhdGlvbigoYSwgYikgPT4gMSkKICAgICAgY29uc3Qgcm9vdCA9IGQzCiAgICAgICAgLmhpZXJhcmNoeShkYXRhLCAoZCkgPT4gZC5icmFuY2hzZXQpCiAgICAgICAgLnN1bSgoZCkgPT4gKGQuYnJhbmNoc2V0ID8gMCA6IDEpKQogICAgICAgIC5zb3J0KAogICAgICAgICAgKGEsIGIpID0+CiAgICAgICAgICAgIGEudmFsdWUgLSBiLnZhbHVlIHx8IGQzLmFzY2VuZGluZyhhLmRhdGEubGVuZ3RoLCBiLmRhdGEubGVuZ3RoKQogICAgICAgICkKCiAgICAgIGNsdXN0ZXIocm9vdCkKICAgICAgc2V0UmFkaXVzKHJvb3QsIChyb290LmRhdGEubGVuZ3RoID0gMCksIGlubmVyUmFkaXVzIC8gbWF4TGVuZ3RoKHJvb3QpKQogICAgICBzZXRDb2xvcihyb290KQoKICAgICAgY29uc3Qgc3ZnID0gZDMKICAgICAgICAuc2VsZWN0KCcuY29udGFpbmVyJykKICAgICAgICAuYXBwZW5kKCdzdmcnKQogICAgICAgIC5hdHRyKCd2aWV3Qm94JywgWy1vdXRlclJhZGl1cywgLW91dGVyUmFkaXVzLCB3aWR0aCwgd2lkdGhdKQogICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJykKICAgICAgICAuYXR0cignZm9udC1zaXplJywgMTApCgogICAgICBzdmcuYXBwZW5kKCdnJykuY2FsbChsZWdlbmQpCgogICAgICBzdmcuYXBwZW5kKCdzdHlsZScpLnRleHQoYAoKLmxpbmstLWFjdGl2ZSB7CiAgc3Ryb2tlOiAjMDAwICFpbXBvcnRhbnQ7CiAgc3Ryb2tlLXdpZHRoOiAxLjVweDsKfQoKLmxpbmstZXh0ZW5zaW9uLS1hY3RpdmUgewogIHN0cm9rZS1vcGFjaXR5OiAuNjsKfQoKLmxhYmVsLS1hY3RpdmUgewogIGZvbnQtd2VpZ2h0OiBib2xkOwp9CgpgKQoKICAgICAgY29uc3QgbGlua0V4dGVuc2lvbiA9IHN2ZwogICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQogICAgICAgIC5hdHRyKCdzdHJva2UnLCAnIzAwMCcpCiAgICAgICAgLmF0dHIoJ3N0cm9rZS1vcGFjaXR5JywgMC4yNSkKICAgICAgICAuc2VsZWN0QWxsKCdwYXRoJykKICAgICAgICAuZGF0YShyb290LmxpbmtzKCkuZmlsdGVyKChkKSA9PiAhZC50YXJnZXQuY2hpbGRyZW4pKQogICAgICAgIC5qb2luKCdwYXRoJykKICAgICAgICAuZWFjaChmdW5jdGlvbihkKSB7CiAgICAgICAgICBkLnRhcmdldC5saW5rRXh0ZW5zaW9uTm9kZSA9IHRoaXMKICAgICAgICB9KQogICAgICAgIC5hdHRyKCdkJywgbGlua0V4dGVuc2lvbkNvbnN0YW50KQoKICAgICAgY29uc3QgbGluayA9IHN2ZwogICAgICAgIC5hcHBlbmQoJ2cnKQogICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKQogICAgICAgIC5hdHRyKCdzdHJva2UnLCAnIzAwMCcpCiAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpCiAgICAgICAgLmRhdGEocm9vdC5saW5rcygpKQogICAgICAgIC5qb2luKCdwYXRoJykKICAgICAgICAuZWFjaChmdW5jdGlvbihkKSB7CiAgICAgICAgICBkLnRhcmdldC5saW5rTm9kZSA9IHRoaXMKICAgICAgICB9KQogICAgICAgIC5hdHRyKCdkJywgbGlua0NvbnN0YW50KQogICAgICAgIC5hdHRyKCdzdHJva2UnLCAoZCkgPT4gZC50YXJnZXQuY29sb3IpCgogICAgICBzdmcKICAgICAgICAuYXBwZW5kKCdnJykKICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JykKICAgICAgICAuZGF0YShyb290LmxlYXZlcygpKQogICAgICAgIC5qb2luKCd0ZXh0JykKICAgICAgICAuYXR0cignZHknLCAnLjMxZW0nKQogICAgICAgIC5hdHRyKAogICAgICAgICAgJ3RyYW5zZm9ybScsCiAgICAgICAgICAoZCkgPT4KICAgICAgICAgICAgYHJvdGF0ZSgke2QueCAtIDkwfSkgdHJhbnNsYXRlKCR7aW5uZXJSYWRpdXMgKyA0fSwwKSR7CiAgICAgICAgICAgICAgZC54IDwgMTgwID8gJycgOiAnIHJvdGF0ZSgxODApJwogICAgICAgICAgICB9YAogICAgICAgICkKICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAoZCkgPT4gKGQueCA8IDE4MCA/ICdzdGFydCcgOiAnZW5kJykpCiAgICAgICAgLnRleHQoKGQpID0+IGQuZGF0YS5uYW1lLnJlcGxhY2UoL18vZywgJyAnKSkKICAgICAgICAub24oJ21vdXNlb3ZlcicsIG1vdXNlb3ZlcmVkKHRydWUpKQogICAgICAgIC5vbignbW91c2VvdXQnLCBtb3VzZW92ZXJlZChmYWxzZSkpCgogICAgICBmdW5jdGlvbiB1cGRhdGUoY2hlY2tlZCkgewogICAgICAgIGNvbnN0IHQgPSBkMy50cmFuc2l0aW9uKCkuZHVyYXRpb24oNzUwKQogICAgICAgIGxpbmtFeHRlbnNpb24KICAgICAgICAgIC50cmFuc2l0aW9uKHQpCiAgICAgICAgICAuYXR0cignZCcsIGNoZWNrZWQgPyBsaW5rRXh0ZW5zaW9uVmFyaWFibGUgOiBsaW5rRXh0ZW5zaW9uQ29uc3RhbnQpCiAgICAgICAgbGluay50cmFuc2l0aW9uKHQpLmF0dHIoJ2QnLCBjaGVja2VkID8gbGlua1ZhcmlhYmxlIDogbGlua0NvbnN0YW50KQogICAgICB9CgogICAgICBmdW5jdGlvbiBtb3VzZW92ZXJlZChhY3RpdmUpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQsIGQpIHsKICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdsYWJlbC0tYWN0aXZlJywgYWN0aXZlKQogICAgICAgICAgZDMuc2VsZWN0KGQubGlua0V4dGVuc2lvbk5vZGUpCiAgICAgICAgICAgIC5jbGFzc2VkKCdsaW5rLWV4dGVuc2lvbi0tYWN0aXZlJywgYWN0aXZlKQogICAgICAgICAgICAucmFpc2UoKQogICAgICAgICAgZG8KICAgICAgICAgICAgZDMuc2VsZWN0KGQubGlua05vZGUpCiAgICAgICAgICAgICAgLmNsYXNzZWQoJ2xpbmstLWFjdGl2ZScsIGFjdGl2ZSkKICAgICAgICAgICAgICAucmFpc2UoKQogICAgICAgICAgd2hpbGUgKChkID0gZC5wYXJlbnQpKQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3ZnLm5vZGUoKSwgeyB1cGRhdGUgfSkKICAgIH0KICB9Cn0K"},{"version":3,"sources":["TreeOfLife.vue"],"names":[],"mappings":";;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"TreeOfLife.vue","sourceRoot":"src/lib-components","sourcesContent":["<template>\n  <div class=\"container\"></div>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n\nexport default {\n  name: 'TreeOfLife',\n  data() {\n    return {\n      life:\n        '(Bovine:0.69395,(Gibbon:0.36079,(Orang:0.33636,(Gorilla:0.17147,(Chimp:0.19268, Human:0.11927):0.08386):0.06124):0.15057):0.54939,Mouse:1.21460):0.10;'\n    }\n  },\n  mounted() {\n    this.getChart()\n  },\n  methods: {\n    getChart() {\n      function parseNewick(a) {\n        for (\n          var e = [], r = {}, s = a.split(/\\s*(;|\\(|\\)|,|:)\\s*/), t = 0;\n          t < s.length;\n          t++\n        ) {\n          var n = s[t]\n          switch (n) {\n            case '(':\n              var c = {}\n              ;(r.branchset = [c]), e.push(r), (r = c)\n              break\n            case ',':\n              var c = {}\n              e[e.length - 1].branchset.push(c), (r = c)\n              break\n            case ')':\n              r = e.pop()\n              break\n            case ':':\n              break\n            default:\n              var h = s[t - 1]\n              ')' == h || '(' == h || ',' == h\n                ? (r.name = n)\n                : ':' == h && (r.length = parseFloat(n))\n          }\n        }\n        return r\n      }\n\n      let data = parseNewick(this.life)\n      let width = 900\n      let outerRadius = width / 2\n      let innerRadius = outerRadius - 170\n\n      let legend = (svg) => {\n        const g = svg\n          .selectAll('g')\n          .data(color.domain())\n          .join('g')\n          .attr(\n            'transform',\n            (d, i) => `translate(${-outerRadius},${-outerRadius + i * 20})`\n          )\n\n        g.append('rect')\n          .attr('width', 18)\n          .attr('height', 18)\n          .attr('fill', color)\n\n        g.append('text')\n          .attr('x', 24)\n          .attr('y', 9)\n          .attr('dy', '0.35em')\n          .text((d) => d)\n      }\n\n      function linkStep(startAngle, startRadius, endAngle, endRadius) {\n        const c0 = Math.cos((startAngle = ((startAngle - 90) / 180) * Math.PI))\n        const s0 = Math.sin(startAngle)\n        const c1 = Math.cos((endAngle = ((endAngle - 90) / 180) * Math.PI))\n        const s1 = Math.sin(endAngle)\n        return (\n          'M' +\n          startRadius * c0 +\n          ',' +\n          startRadius * s0 +\n          (endAngle === startAngle\n            ? ''\n            : 'A' +\n              startRadius +\n              ',' +\n              startRadius +\n              ' 0 0 ' +\n              (endAngle > startAngle ? 1 : 0) +\n              ' ' +\n              startRadius * c1 +\n              ',' +\n              startRadius * s1) +\n          'L' +\n          endRadius * c1 +\n          ',' +\n          endRadius * s1\n        )\n      }\n\n      function linkExtensionConstant(d) {\n        return linkStep(d.target.x, d.target.y, d.target.x, innerRadius)\n      }\n\n      function linkExtensionVariable(d) {\n        return linkStep(d.target.x, d.target.radius, d.target.x, innerRadius)\n      }\n\n      function linkConstant(d) {\n        return linkStep(d.source.x, d.source.y, d.target.x, d.target.y)\n      }\n\n      function linkVariable(d) {\n        return linkStep(\n          d.source.x,\n          d.source.radius,\n          d.target.x,\n          d.target.radius\n        )\n      }\n\n      // Set the color of each node by recursively inheriting.\n      function setColor(d) {\n        var name = d.data.name\n        d.color =\n          color.domain().indexOf(name) >= 0\n            ? color(name)\n            : d.parent\n            ? d.parent.color\n            : null\n        if (d.children) d.children.forEach(setColor)\n      }\n\n      // Set the radius of each node by recursively summing and scaling the distance from the root.\n      function setRadius(d, y0, k) {\n        d.radius = (y0 += d.data.length) * k\n        if (d.children) d.children.forEach((d) => setRadius(d, y0, k))\n      }\n\n      // Compute the maximum cumulative length of any node in the tree.\n      function maxLength(d) {\n        return d.data.length + (d.children ? d3.max(d.children, maxLength) : 0)\n      }\n\n      let color = d3\n        .scaleOrdinal()\n        .domain(['Bacteria', 'Eukaryota', 'Archaea'])\n        .range(d3.schemeCategory10)\n\n      let cluster = d3\n        .cluster()\n        .size([360, innerRadius])\n        .separation((a, b) => 1)\n      const root = d3\n        .hierarchy(data, (d) => d.branchset)\n        .sum((d) => (d.branchset ? 0 : 1))\n        .sort(\n          (a, b) =>\n            a.value - b.value || d3.ascending(a.data.length, b.data.length)\n        )\n\n      cluster(root)\n      setRadius(root, (root.data.length = 0), innerRadius / maxLength(root))\n      setColor(root)\n\n      const svg = d3\n        .select('.container')\n        .append('svg')\n        .attr('viewBox', [-outerRadius, -outerRadius, width, width])\n        .attr('font-family', 'sans-serif')\n        .attr('font-size', 10)\n\n      svg.append('g').call(legend)\n\n      svg.append('style').text(`\n\n.link--active {\n  stroke: #000 !important;\n  stroke-width: 1.5px;\n}\n\n.link-extension--active {\n  stroke-opacity: .6;\n}\n\n.label--active {\n  font-weight: bold;\n}\n\n`)\n\n      const linkExtension = svg\n        .append('g')\n        .attr('fill', 'none')\n        .attr('stroke', '#000')\n        .attr('stroke-opacity', 0.25)\n        .selectAll('path')\n        .data(root.links().filter((d) => !d.target.children))\n        .join('path')\n        .each(function(d) {\n          d.target.linkExtensionNode = this\n        })\n        .attr('d', linkExtensionConstant)\n\n      const link = svg\n        .append('g')\n        .attr('fill', 'none')\n        .attr('stroke', '#000')\n        .selectAll('path')\n        .data(root.links())\n        .join('path')\n        .each(function(d) {\n          d.target.linkNode = this\n        })\n        .attr('d', linkConstant)\n        .attr('stroke', (d) => d.target.color)\n\n      svg\n        .append('g')\n        .selectAll('text')\n        .data(root.leaves())\n        .join('text')\n        .attr('dy', '.31em')\n        .attr(\n          'transform',\n          (d) =>\n            `rotate(${d.x - 90}) translate(${innerRadius + 4},0)${\n              d.x < 180 ? '' : ' rotate(180)'\n            }`\n        )\n        .attr('text-anchor', (d) => (d.x < 180 ? 'start' : 'end'))\n        .text((d) => d.data.name.replace(/_/g, ' '))\n        .on('mouseover', mouseovered(true))\n        .on('mouseout', mouseovered(false))\n\n      function update(checked) {\n        const t = d3.transition().duration(750)\n        linkExtension\n          .transition(t)\n          .attr('d', checked ? linkExtensionVariable : linkExtensionConstant)\n        link.transition(t).attr('d', checked ? linkVariable : linkConstant)\n      }\n\n      function mouseovered(active) {\n        return function(event, d) {\n          d3.select(this).classed('label--active', active)\n          d3.select(d.linkExtensionNode)\n            .classed('link-extension--active', active)\n            .raise()\n          do\n            d3.select(d.linkNode)\n              .classed('link--active', active)\n              .raise()\n          while ((d = d.parent))\n        }\n      }\n\n      return Object.assign(svg.node(), { update })\n    }\n  }\n}\n</script>\n\n<style></style>\n"]}]}